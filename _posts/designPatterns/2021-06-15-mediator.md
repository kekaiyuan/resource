---
layout: post
title: 设计模式之——中介者Mediator和外观Facade
categories: DesignPatterns
description: 设计模式之——中介者模式Mediator和外观模式Facade
keywords: Java，设计模式
---

设计模式之——中介者Mediator和外观Facade

# 中介者模式Mediator

## 什么是中介者？

假设现在你有五个模块，这五个模块之间互有联系。

 ![enter description here](/images/posts/designpatterns/mediator-facade/mediator-01.png)

联系有点复杂。

如果模块数量继续增加，联系会变得十分复杂。

所以我们需要一个“中介者”，帮我们调停模块之间的联系。

 ![enter description here](/images/posts/designpatterns/mediator-facade/mediator-02.png)

消息中间件的概念也是据此提出的。

模块们把消息送给中间件，然后从中间件拿自己需要的消息。

我的消息应该送给谁？我应该从谁哪里拿消息？这些问题就不需要考虑了，程序耦合度会大大降低。

消息队列的概念亦是如此，所有的消息都放在队列中，想要什么消息自己取，而不是等着谁来发给你你所需要的消息。

消息队列就类似于菜鸟驿站，快递员只负责把快递送到驿站，不负责送到每个人手里。谁有快递自己去驿站取。


## 概念

> 以下内容引用自[https://www.runoob.com/design-pattern/mediator-pattern.html](https://www.runoob.com/design-pattern/mediator-pattern.html)
> 
> - 意图
> 	- 用一个中介对象来封装一系列的对象交互，中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。
> 
> - 主要解决
> 	- 对象与对象之间存在大量的关联关系，这样势必会导致系统的结构变得很复杂，同时若一个对象发生改变，我们也需要跟踪与之相关联的对象，同时做出相应的处理。
> 
> - 何时使用
> 	- 多个类相互耦合，形成了**网状**结构。
> 
> - 如何解决
> 	- 将上述网状结构分离为**星型**结构。
> 
> - 关键代码
> 	- 对象 Colleague 之间的**通信封装**到一个类中单独处理。
> 
> - 应用实例
> 	- 中国加入 WTO 之前是各个国家相互贸易，结构复杂，现在是各个国家通过 WTO 来互相贸易。
> 	- 机场调度系统。 
> 	- **MVC** 框架，其中C（控制器）就是 M（模型）和 V（视图）的调停者。
> 
> - 优点
> 	- 降低了类的复杂度，将一对多转化成了一对一。 
> 	- 各个类之间的**解耦**。 
> 	- 符合迪米特原则。
> 		- 迪米特法则（Law of Demeter）又叫作最少知识原则（The Least Knowledge Principle），一个类对于其他类知道的越少越好，就是说一个对象应当对其他对象有尽可能少的了解,只和朋友通信，不和陌生人说话。英文简写为: LOD。
> 
> - 缺点
> 	- 中介者会庞大，变得复杂难以维护。
> 
> - 使用场景：
> 	- 系统中对象之间存在比较复杂的引用关系，导致它们之间的依赖关系结构混乱而且难以复用该对象。
> 	- 想通过一个中间类来封装多个类中的行为，而又不想生成太多的子类。
> 
> - 注意事项
> 	- 不应当在职责混乱的时候使用。

# 外观模式Facade

## 什么是外观模式？

外观模式和中介者模式非常像，其核心思想都是把程序解耦，把各个模块之间的复杂联系集中到一个单独的类中。

区别在于一个是外部联系，一个是内部联系。

比如说现在有一家公司，人员和业务非常多。

前台就是外观模式，他负责帮助外来人员和公司之间的联系。

而公司内部负责协调工作的小组就是中介者模式，他负责协调公司内部各个部门之间的联系。

又比如MVC模式，对于Model来说，Controller是中介者，因为每个Model都是和其他Model联系在一起的，他们是一个群体，Controller是**内部**的“协调器”，是中介者。

对于View来说，Controller是外观模式，因为View和Model之间的联系不强，View只是拿到Model处理好的数据并显示而已，View和Model是两个群体，作为联系两个群体的Controller对于View而言是一个**外部**的“协调器”，是外观模式。

加入外观模式之前：

![enter description here](/images/posts/designpatterns/mediator-facade/facade-01.png)

加入外观模式之后：

![enter description here](/images/posts/designpatterns/mediator-facade/facade-02.png)

## 概念
外观模式（Facade Pattern）隐藏系统的复杂性，并向客户端提供了一个客户端可以访问系统的接口。这种类型的设计模式属于结构型模式，它向现有的系统添加一个接口，来隐藏系统的复杂性。

这种模式涉及到一个单一的类，该类提供了客户端请求的简化方法和对现有系统类方法的委托调用。

> 以下内容引用自[https://www.runoob.com/design-pattern/facade-pattern.html](https://www.runoob.com/design-pattern/facade-pattern.html)
> 
> - 意图
> 	- 为子系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。
> 
> - 主要解决
> 	- 降低访问复杂系统的内部子系统时的复杂度，简化客户端与之的接口。
> 
> - 何时使用
> 	- 客户端不需要知道系统内部的复杂联系，整个系统只需提供一个"接待员"即可。
> 	- 定义系统的入口。
> 
> - 如何解决
> 	- 客户端不与系统耦合，外观类与系统耦合。
> 
> - 关键代码
> 	- 在客户端和复杂系统之间再加一层，这一层将调用顺序、依赖关系等处理好。
> 
> - 应用实例
> 	- 去医院看病，可能要去挂号、门诊、划价、取药，让患者或患者家属觉得很复杂，如果有提供接待人员，只让接待人员来处理，就很方便。
> 	- JAVA 的三层开发模式。
> 
> - 优点
> 	- 减少系统相互依赖。
> 	- 提高灵活性。 
> 	- 提高了安全性。
> 
> - 缺点
> 	- 不符合开闭原则，如果要改东西很麻烦，继承重写都不合适。
> 		- 开闭原则
> 			- 对拓展开放，对修改关闭。
> 			- 可以加新功能，但是不要修改原有功能的代码。
> 
> - 使用场景
> 	- 为复杂的模块或子系统提供外界访问的模块。
> 	- 子系统相对独立。 
> 	- 预防低水平人员带来的风险。
> 
> - 注意事项
> 	- 在层次化结构中，可以使用外观模式定义系统中每一层的入口。

# 总结
中介者模式和外观模式并不是类似于单例模式有特定模板的模式，它们体现的是封装的思想。

假如有A、B、C、D、E五个人，让A和B、C、D、E都建立联系的话，就是四个联系。

封装出一个单独的类的话，A就只需要与这个类建立联系，这样就只有一个联系。

在程序过于复杂的时候，我们甚至可以采取多重中介者模式。

例如快递网络。

小镇的运输中心聚集附近村子的快递，城市的运输中心聚集附近小镇的，省会的运输中心聚集该省的快递，在这之上还有按地域划分的运输中心：比如华东运输中心、华南运输中心……通过这多重网络才真正覆盖全国。

外观模式亦是如此。

在一家大医院里，除了一楼有前台，每层楼也会有前台。