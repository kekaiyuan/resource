---
layout: post
title: MySQL 之——执行计划
categories: MySQL
description: MySQL 之——执行计划
keywords: MySQL, 执行计划
---

MySQL 之——执行计划

# 序言
在企业项目中，SQL 语句的优化是十分重要的一个点，两个 SQL 语句可能实现的内容一样，但是性能上却天差地别。

于是类似于我们 C++, Java 中的 Debug 模式一样。<br>
在 MySQL 中可以使用 `explain + SQL 语句` 来查看**查询**语句执行的细节，从而针对性地对其优化。

[MySQL 官网](https://dev.mysql.com/doc/refman/5.5/en/explain-output.html) 

# 执行计划中包含的信息
执行计划一共包含以下内容：

|    Column     |                    Meaning                     |
| :-----------: | :--------------------------------------------: |
|      id       |            The `SELECT` identifier             |
|  select_type  |               The `SELECT` type                |
|     table     |          The table for the output row          |
|  partitions   |            The matching partitions             |
|     type      |                 The join type                  |
| possible_keys |         The possible indexes to choose         |
|      key      |           The index actually chosen            |
|    key_len    |          The length of the chosen key          |
|      ref      |       The columns compared to the index        |
|     rows      |        Estimate of rows to be examined         |
|   filtered    | Percentage of rows filtered by table condition |
|     extra     |             Additional information             |

## id
一个 `select` 语句往往包含多个 `select` 语句。<br>
**id** 用于表示这些语句的执行顺序。

执行顺序：
1. 优先执行 id 大的。
2. id 相同，从上往下执行。

## select_type

主要用来分辨查询的类型，是普通查询还是联合查询还是子查询

| `select_type` Value  |                           Meaning                            |
| :------------------: | :----------------------------------------------------------: |
|        SIMPLE        |        Simple SELECT (not using UNION or subqueries)         |
|       PRIMARY        |                       Outermost SELECT                       |
|        UNION         |         Second or later SELECT statement in a UNION          |
|   DEPENDENT UNION    | Second or later SELECT statement in a UNION, dependent on outer query |
|     UNION RESULT     |                      Result of a UNION.                      |
|       SUBQUERY       |                   First SELECT in subquery                   |
|  DEPENDENT SUBQUERY  |      First SELECT in subquery, dependent on outer query      |
|       DERIVED        |                        Derived table                         |
| UNCACHEABLE SUBQUERY | A subquery for which the result cannot be cached and must be re-evaluated for each row of the outer query |
|  UNCACHEABLE UNION   | The second or later select in a UNION that belongs to an uncacheable subquery (see UNCACHEABLE SUBQUERY) |




### simple

简单的查询，不包含子查询和union
```sql
EXPLAIN SELECT
	*
FROM
	emp;
```
```
+----+-------------+-------+------+---------------+------+---------+------+------+-------+
| id | select_type | table | type | possible_keys | key  | key_len | ref  | rows | Extra |
+----+-------------+-------+------+---------------+------+---------+------+------+-------+
|  1 | SIMPLE      | emp   | ALL  | NULL          | NULL | NULL    | NULL |   14 |       |
+----+-------------+-------+------+---------------+------+---------+------+------+-------+
```

----------

### primary

查询中若包含任何复杂的子查询，最外层查询则被标记为Primary
```sql
EXPLAIN SELECT
	*
FROM
	(SELECT ename, mgr FROM emp) e;
```
```
+----+-------------+------------+------+---------------+------+---------+------+------+-------+
| id | select_type | table      | type | possible_keys | key  | key_len | ref  | rows | Extra |
+----+-------------+------------+------+---------------+------+---------+------+------+-------+
|  1 | PRIMARY     | <derived2> | ALL  | NULL          | NULL | NULL    | NULL |   14 |       |
|  2 | DERIVED     | emp        | ALL  | NULL          | NULL | NULL    | NULL |   14 |       |
+----+-------------+------------+------+---------------+------+---------+------+------+-------+
```



- union<br>
	若第二个或之后的select出现在union之后，则被标记为union
	```sql
	EXPLAIN SELECT
		*
	FROM
		emp
	WHERE
		deptno = 10
	UNION
		SELECT
			*
		FROM
			emp
		WHERE
			sal > 2000;
		```
	union 先执行
- dependent union<br>
	跟union类似，此处的depentent表示union或union all联合而成的结果会受外部表影响
	```sql
	EXPLAIN SELECT
		*
	FROM
		emp e
	WHERE
		e.empno IN (
			SELECT
				empno
			FROM
				emp
			WHERE
				deptno = 10
			UNION
				SELECT
					empno
				FROM
					emp
				WHERE
					sal > 2000
		);
	```
- union result<br>
	从union表获取结果的select
	```sql
	EXPLAIN SELECT
		*
	FROM
		emp
	WHERE
		deptno = 10
	UNION
		SELECT
			*
		FROM
			emp
		WHERE
			sal > 2000;
	```
- subquery<br>
	在select或者where列表中包含子查询
	```sql
	EXPLAIN SELECT
		*
	FROM
		emp
	WHERE
		sal > (SELECT avg(sal) FROM emp);
	```
- dependent subquery<br>
	subquery的子查询要受到外部表查询的影响
	```sql
	EXPLAIN SELECT
		*
	FROM
		emp
	WHERE
		sal IN (SELECT avg(sal) FROM emp);
	```
	该 sql 语句只是把 subquery 的 sql 语句的 > 改成了 IN ，就变成了 dependent subquery。<br>
	说实话，没搞懂 MySQL 的判断机制。<br>
	但是有一点是确定的，dependent subquery 在执行的时候，会先把整个外部表都查出来，然后再一一的和子查询的所有结果进行匹配。<br>
	假设外部表有 m 条数据，子查询的表有 n 条数据。<br>
	那么要进行 m \* n 次匹配，次数爆炸！<br>
	看到 dependent subquery 一定要想办法改造 sql 语句避开。
- DERIVED<br>
	from子句中出现的子查询，也叫做派生类，
	```sql
	EXPLAIN SELECT
		staname,
		ename supname
	FROM
		(
			SELECT
				ename staname,
				mgr
			FROM
				emp
		) t
	JOIN emp ON t.mgr = emp.empno;
	```
- UNCACHEABLE SUBQUERY<br>
	表示使用子查询的结果不能被缓存
	```sql
	EXPLAIN SELECT
		*
	FROM
		emp
	WHERE
		empno = (
			SELECT
				empno
			FROM
				emp
			WHERE
				deptno =@@sort_buffer_size
		);
	 ```
- uncacheable union<br>
	表示union的查询结果不能被缓存：sql语句未验证


## table
表示对应行正在访问哪一个表，可以是表名或别名，可能是临时表或者 union 合并结果集。

1. 如果是**具体的表名**，则表明从实际的物理表中获取数据，当然也可以是表的别名。
2. 表名是 `derived N` 的形式，表示使用了 id 为 N 的查询产生的**衍生表**。
3. 当有 `union result` 的时候，表名是 `union n1,n2 等` 的形式，n1,n2 表示参与 union 的 id。

## type
type 表示访问类型，访问类型表示我是以何种方式去访问我们的数据，最容易想的是全表扫描，直接暴力的遍历一张表去寻找需要的数据，效率非常低下，访问的类型有很多，效率从最好到最坏依次是：

system > const > eq_ref > ref > fulltext > ref_or_null > index_merge > unique_subquery > index_subquery > range > index > all

一般情况下，得保证查询至少达到 range 级别，最好能达到 ref

| type | 说明 |
| :--: | :-- |
| all | 全表扫描 |
| index | 全索引扫描<br>两种情况<br>1. 当前查询覆盖索引，即需要的数据在索引中。<br>2. 使用了索引进行排序。 |
| range | |
| index_subquery | |
| unique_subquery | |
| index_merge | |
| ref_or_null | |
| fulltext | |
| ref | |
| eq_ref | |
| const | |
| system | |

```sql
--all:全表扫描，一般情况下出现这样的sql语句而且数据量比较大的话那么就需要进行优化。
explain select * from emp;

--index：全索引扫描这个比all的效率要好，主要有两种情况，一种是当前的查询时覆盖索引，即我们需要的数据在索引中就可以索取，或者是使用了索引进行排序，这样就避免数据的重排序
explain  select empno from emp;

--range：表示利用索引查询的时候限制了范围，在指定范围内进行查询，这样避免了index的全索引扫描，适用的操作符： =, <>, >, >=, <, <=, IS NULL, BETWEEN, LIKE, or IN() 
explain select * from emp where empno between 7000 and 7500;

--index_subquery：利用索引来关联子查询，不再扫描全表
explain select * from emp where emp.job in (select job from t_job);

--unique_subquery:该连接类型类似与index_subquery,使用的是唯一索引
 explain select * from emp e where e.deptno in (select distinct deptno from dept);
 
--index_merge：在查询过程中需要多个索引组合使用，没有模拟出来

--ref_or_null：对于某个字段即需要关联条件，也需要null值的情况下，查询优化器会选择这种访问方式
explain select * from emp e where  e.mgr is null or e.mgr=7369;

--ref：使用了非唯一性索引进行数据的查找
 create index idx_3 on emp(deptno);
 explain select * from emp e,dept d where e.deptno =d.deptno;

--eq_ref ：使用唯一性索引进行数据查找
explain select * from emp,emp2 where emp.empno = emp2.empno;

--const：这个表至多有一个匹配行，
explain select * from emp where empno = 7369;
 
--system：表只有一行记录（等于系统表），这是const类型的特例，平时不会出现
```

 possible_keys 

​        显示可能应用在这张表中的索引，一个或多个，查询涉及到的字段上若存在索引，则该索引将被列出，但不一定被查询实际使用

```sql
explain select * from emp,dept where emp.deptno = dept.deptno and emp.deptno = 10;
```

key

实际使用的索引，如果为null，则没有使用索引，查询中若使用了覆盖索引，则该索引和查询的select字段重叠。

```sql
explain select * from emp,dept where emp.deptno = dept.deptno and emp.deptno = 10;
```

key_len

表示索引中使用的字节数，可以通过key_len计算查询中使用的索引长度，在不损失精度的情况下长度越短越好。

```sql
explain select * from emp,dept where emp.deptno = dept.deptno and emp.deptno = 10;
```

ref

显示索引的哪一列被使用了，如果可能的话，是一个常数

```sql
explain select * from emp,dept where emp.deptno = dept.deptno and emp.deptno = 10;
```

rows

根据表的统计信息及索引使用情况，大致估算出找出所需记录需要读取的行数，此参数很重要，直接反应的sql找了多少数据，在完成目的的情况下越少越好

```sql
explain select * from emp;
```

extra

包含额外的信息。

```sql
--using filesort:说明mysql无法利用索引进行排序，只能利用排序算法进行排序，会消耗额外的位置
explain select * from emp order by sal;

--using temporary:建立临时表来保存中间结果，查询完成之后把临时表删除
explain select ename,count(*) from emp where deptno = 10 group by ename;

--using index:这个表示当前的查询时覆盖索引的，直接从索引中读取数据，而不用访问数据表。如果同时出现using where 表名索引被用来执行索引键值的查找，如果没有，表面索引被用来读取数据，而不是真的查找
explain select deptno,count(*) from emp group by deptno limit 10;

--using where:使用where进行条件过滤
explain select * from t_user where id = 1;

--using join buffer:使用连接缓存，情况没有模拟出来

--impossible where：where语句的结果总是false
explain select * from emp where empno = 7469;
```

